## ðŸŸ¦ Queue & Deque Utilities â€“ Python

```python
from collections import deque
from typing import List, Optional
```

---

## 1ï¸âƒ£ Sliding Window Maximum

> Classic **deque + monotonic queue**

```python
def sliding_window_max(nums: List[int], k: int) -> List[int]:
    dq = deque()   # stores indices
    result = []

    for i in range(len(nums)):
        # Remove out-of-window indices
        if dq and dq[0] <= i - k:
            dq.popleft()

        # Maintain decreasing order
        while dq and nums[dq[-1]] <= nums[i]:
            dq.pop()

        dq.append(i)

        if i >= k - 1:
            result.append(nums[dq[0]])

    return result
```

---

## 2ï¸âƒ£ First Negative Number in Every Window

```python
def first_negative_in_window(arr: List[int], k: int) -> List[int]:
    q = deque()
    result = []

    for i in range(len(arr)):
        if arr[i] < 0:
            q.append(i)

        if q and q[0] <= i - k:
            q.popleft()

        if i >= k - 1:
            result.append(arr[q[0]] if q else 0)

    return result
```

---

## 3ï¸âƒ£ Level Order Traversal (Binary Tree)

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def level_order(root: Optional[TreeNode]) -> List[List[int]]:
    if not root:
        return []

    q = deque([root])
    result = []

    while q:
        level = []
        for _ in range(len(q)):
            node = q.popleft()
            level.append(node.val)

            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)

        result.append(level)

    return result
```

---

## 4ï¸âƒ£ Implement Queue Using Deque

```python
class Queue:
    def __init__(self):
        self.q = deque()

    def enqueue(self, x):
        self.q.append(x)

    def dequeue(self):
        return self.q.popleft() if self.q else None

    def peek(self):
        return self.q[0] if self.q else None

    def is_empty(self):
        return not self.q
```

---

## 5ï¸âƒ£ Generate Binary Numbers (1 to N)

```python
def generate_binary(n: int) -> List[str]:
    result = []
    q = deque(["1"])

    for _ in range(n):
        curr = q.popleft()
        result.append(curr)

        q.append(curr + "0")
        q.append(curr + "1")

    return result
```

---

## ðŸ§ª Example Usage

```python
print(sliding_window_max([1,3,-1,-3,5,3,6,7], 3))
# [3,3,5,5,6,7]

print(first_negative_in_window([12,-1,-7,8,-15,30,16,28], 3))
# [-1,-1,-7,-15,0,0]

print(generate_binary(5))
# ['1','10','11','100','101']
```

---

## ðŸ§  Queue / Deque Pattern Recognition

Use **deque** when:

* Sliding window with **max/min**
* Need **O(1)** push/pop from both ends
* Processing in **FIFO** order
* BFS / level traversal

---

### ðŸ”¥ Interview Power Rule

> **Stack â†’ depth
> Queue â†’ breadth**

---
