## ðŸŸ¦ Recursion Utilities â€“ Python

```python
from functools import lru_cache
```

---

### 1ï¸âƒ£ Factorial

```python
def factorial(n: int) -> int:
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```

---

### 2ï¸âƒ£ Fibonacci

```python
def fibonacci(n: int) -> int:
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)
```

ðŸ‘‰ Optimized (Memoization):

```python
@lru_cache(None)
def fibonacci_fast(n: int) -> int:
    if n <= 1:
        return n
    return fibonacci_fast(n - 1) + fibonacci_fast(n - 2)
```

---

### 3ï¸âƒ£ Reverse String Recursively

```python
def reverse_string_rec(s: str) -> str:
    if len(s) <= 1:
        return s
    return reverse_string_rec(s[1:]) + s[0]
```

---

### 4ï¸âƒ£ Power Function (xâ¿)

```python
def power(x: float, n: int) -> float:
    if n == 0:
        return 1
    if n < 0:
        return 1 / power(x, -n)
    return x * power(x, n - 1)
```

ðŸ‘‰ Fast Exponentiation:

```python
def power_fast(x: float, n: int) -> float:
    if n == 0:
        return 1
    half = power_fast(x, n // 2)
    return half * half if n % 2 == 0 else x * half * half
```

---

### 5ï¸âƒ£ Check Palindrome Recursively

```python
def is_palindrome_rec(s: str, left: int = 0, right: int = None) -> bool:
    if right is None:
        right = len(s) - 1

    if left >= right:
        return True
    if s[left] != s[right]:
        return False

    return is_palindrome_rec(s, left + 1, right - 1)
```

---

## ðŸ§ª Example Usage

```python
print(factorial(5))            # 120
print(fibonacci_fast(10))      # 55
print(reverse_string_rec("abc"))  # cba
print(power_fast(2, 10))       # 1024
print(is_palindrome_rec("madam"))  # True
```

---

## ðŸ§  Recursion Mindset (Memorize This)

Every recursion needs:

1. **Base case** ðŸ›‘
2. **Smaller subproblem** ðŸ”
3. **Trust the function** ðŸ™

---

### ðŸ”¥ Interview Gold Rule

> If you can write it recursively,
> you can usually convert it to **DP**.

---
