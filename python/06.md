## ðŸŸ¦ Sliding Window â€“ Python Utilities

```python
from typing import List
from collections import defaultdict, Counter
```

---

## ðŸŸ© FIXED WINDOW

### 1ï¸âƒ£ Maximum Sum Subarray of Size `k`

```python
def max_sum_subarray(arr: List[int], k: int) -> int:
    if k > len(arr):
        return 0

    window_sum = sum(arr[:k])
    max_sum = window_sum

    for i in range(k, len(arr)):
        window_sum += arr[i] - arr[i - k]
        max_sum = max(max_sum, window_sum)

    return max_sum
```

---

## ðŸŸ¨ VARIABLE WINDOW

### 2ï¸âƒ£ Longest Substring Without Repeating Characters

```python
def longest_unique_substring(s: str) -> int:
    window = set()
    left = 0
    max_len = 0

    for right in range(len(s)):
        while s[right] in window:
            window.remove(s[left])
            left += 1

        window.add(s[right])
        max_len = max(max_len, right - left + 1)

    return max_len
```

---

### 3ï¸âƒ£ Longest Substring with `k` Distinct Characters

```python
def longest_k_distinct(s: str, k: int) -> int:
    freq = defaultdict(int)
    left = 0
    max_len = 0

    for right in range(len(s)):
        freq[s[right]] += 1

        while len(freq) > k:
            freq[s[left]] -= 1
            if freq[s[left]] == 0:
                del freq[s[left]]
            left += 1

        max_len = max(max_len, right - left + 1)

    return max_len
```

---

### 4ï¸âƒ£ Count Subarrays with Given Sum (Prefix Sum + Hashing)

> Works for **negative numbers too**

```python
def count_subarrays_with_sum(arr: List[int], target: int) -> int:
    prefix_sum = 0
    count = 0
    freq = defaultdict(int)
    freq[0] = 1

    for num in arr:
        prefix_sum += num
        count += freq[prefix_sum - target]
        freq[prefix_sum] += 1

    return count
```

âš ï¸ **Important**:
This is *not* classic sliding window, but interviewers group it here.

---

### 5ï¸âƒ£ Minimum Window Substring

> Classic FAANG-level problem

```python
def min_window(s: str, t: str) -> str:
    if not s or not t:
        return ""

    need = Counter(t)
    window = defaultdict(int)
    have = 0
    need_count = len(need)

    left = 0
    res = (-1, -1)
    res_len = float("inf")

    for right in range(len(s)):
        ch = s[right]
        window[ch] += 1

        if ch in need and window[ch] == need[ch]:
            have += 1

        while have == need_count:
            if (right - left + 1) < res_len:
                res = (left, right)
                res_len = right - left + 1

            window[s[left]] -= 1
            if s[left] in need and window[s[left]] < need[s[left]]:
                have -= 1
            left += 1

    l, r = res
    return s[l:r + 1] if res_len != float("inf") else ""
```

---

## ðŸ§ª Example Usage

```python
print(max_sum_subarray([2,1,5,1,3,2], 3))     # 9
print(longest_unique_substring("abcabcbb"))  # 3
print(longest_k_distinct("eceba", 2))        # 3
print(count_subarrays_with_sum([1,1,1], 2))  # 2
print(min_window("ADOBECODEBANC", "ABC"))    # BANC
```

---

## ðŸ§  Sliding Window Cheat Sheet

### âœ… Use **Fixed Window** when:

* Window size is given (`k`)
* Sum / average / max / min

### âœ… Use **Variable Window** when:

* Longest / shortest substring
* Distinct / unique conditions
* Frequency constraints

### ðŸš« Donâ€™t use sliding window when:

* Negative numbers + window condition depends on sum
  â†’ Use **prefix sum + hashmap**

---

### ðŸ”¥ Interview Super Rule

> **If you expand with right pointer,
> you MUST know when & how to shrink with left.**
